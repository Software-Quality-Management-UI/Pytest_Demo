# Defaults apply to all job definitions
default:
  # Minimal pixi image
  image: ghcr.io/prefix-dev/pixi:latest
  # Directories to cache and key to identify cache
  cache:
    key: mycachekey
    paths:
      - .pixi/
      - "$CI_PROJECT_DIR/.pixidust"

# While variables are passed to all jobs definitions,
# they are not defined within "default" section
variables:
  # RATTLER_CACHE_DIR is the backend for pixi, see https://github.com/prefix-dev/pixi/pull/683
  # CI_PROJECT_DIR is a predefined variable, see https://docs.gitlab.com/ee/ci/variables/predefined_variables.html
  RATTLER_CACHE_DIR: "$CI_PROJECT_DIR/.pixidust"

# Pre-defined stages documented here: https://docs.gitlab.com/ee/ci/yaml/#stages
setup_pixi:
  stage: .pre
  script:
    - pixi install

# Define some compile job to be used as build stage (calls pdm in pixi)
mycompile:
  stage: build
  # Execute command, prefixed with pixi run
  script:
    - pixi run pip install build
    - pixi run python -m build -v
    - pixi run cover # Generate combined coverage
  # Regex to parse lcov --list
  # Breakdown of the regex:
  # 1. 'Total:' matches the line where the overall coverage summary begins.
  # 2. '\|\d+\.\d+%\s+\d+' is used to match and skip the line coverage percentage and the associated count.
  # 3. '\|\d+\.\d+%\s+\d+' is used again to match and skip the function coverage percentage and count.
  # 4. '\|(\d+\.\d+%)' captures the branch coverage percentage.
  # 5. '\s+\d+' skips the number of branches associated with the branch coverage percentage.
  # 6. '$' ensures that this regex matches at the end of the relevant line.
  #
  # Example match from output:
  # Total:       |92.3%     39|83.3%     6|41.9%     31
  #
  # Explanation of captured groups:
  # 1. 'Total:' identifies the line with the overall coverage summary.
  # 2. The regex skips the Line and Function coverage fields:
  #    - '\|\d+\.\d+%\s+\d+' matches the Line coverage percentage and count.
  #    - '\|\d+\.\d+%\s+\d+' matches the Function coverage percentage and count.
  # 3. The final part captures the Branch coverage percentage:
  #    - '\|(\d+\.\d+%)' captures the Branch coverage percentage (e.g., '41.9%').
  # 4. '\s+\d+' skips the branch count.
  # 5. '$' anchors the match to the end of the line.
  #
  coverage: '/Total:\|\d+\.\d+%\s+\d+\|\d+\.\d+%\s+\d+\|(\d+\.\d+)%\s+\d+$/'
  artifacts:
    paths:
      - "src"
      - "dist"
      - "tests"
      - "pixi.toml"
      - "pixi.lock"
      - "coverage.combined"
    expire_in: 1h

# Define some unit test job to be used as (unit) test stage
myunittest:
  # In Gitlab, stage test   # runs after stage build
  stage: test
  # Prevent git clone (we import files as artefacts from previous stage).
  variables:
    GIT_STRATEGY: none
  # Execute test command
  script:
    - pixi run pip install dist/pybtst2024-0.1.0-cp311-cp311-linux_x86_64.whl
    - pixi run pytest --cov=pybtst2024 --junitxml=tests_junitstyle.xml
    - pixi run pip install lcov_cobertura # Convert to cobertura
    - pixi run lcov_cobertura coverage.combined -d # -d demangles with c++flit
  # Use artifact files from mycompile build phase as input
  dependencies:
    - mycompile
  artifacts:
    when: always # We want this artifact also when pipeline (=tests) failed.
    reports: # Special report artifact type
      junit:
        - "tests_junitstyle.xml"
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - "src"
      - "coverage.combined"
      - "pixi.toml"
      - "pixi.lock"
    expire_in: 1h

# Web page generation job to be used as deploy stage
# Important: the name of this job must be "pages", otherwise, GitLab will not publish it via GitLab pages!
pages:
  # Gitlab runs stage deploy after stage test
  stage: deploy
  # Prevent any git clone (we import files as artefacts from previous stage).
  variables:
    GIT_STRATEGY: none
  # Execute command
  script:
    - pixi run genhtml -o covHTML coverage.combined --demangle-cpp
    - mkdir public
    - mv covHTML/* public/
  artifacts:
    # The generated web pages in directory public needs be exported as artifact
    paths:
      - public
    expire_in: 1 h
  # Use artifact files from myunittest job as input
  dependencies:
    - myunittest
  only: # Execute only when to main or master branch has been committed
    - main
    - cidemo
